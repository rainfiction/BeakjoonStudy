0.
대부분 코딩테스트 문제 난이도는 실버3~골드1정도의 난이도.


1.
동적 배열은 범위 기반 for문을 사용할 수 없다. vector로 바꾸거나 기존 c의 for문을 사용하거나 해야 함.
실전에서는 무조건 vector 사용이 우선이라 함.
(1920.cpp참고)


2.
ios::sync_with_stdio(false);
cin.tie(NULL);
이거 쓰면 알고리즘 속도가 조금은 빨라짐.
자매품으로 cout.tie(NULL);도 사용할 수 있긴 한데... 기본적으로 cout은 다른 스트림에 tie되어 있지 않기 때문에 cout.tie(NULL);은 무의미하거나 생략 가능하다.


3.
2의 제곱을 연산하는 경우 pow보다 비트 연산을 사용하는 것이 정밀도, 속도 면에서 편리하다. pow는 입력된 자료형을 한 번 double로 변환한 다음 다시 입력 자료형을 변환해줘서 크기가 커질수록 오차도 커진다. 때문에 오차 범위가 작게 주어지는 알고리즘 문제에서 오답이 나올 가능성이 높다.


4.
C++은 성능을 위해 출력 버퍼링이 더 적극적이다. 그래서 출력이 바로 안 보일 때 flush나 endl을 써야 즉시 화면에 보인다. C는 상대적으로 \n만으로도 바로 출력되는 경우가 많기에 코드 오류로 헷갈리기 쉬움.


5.
메모이제이션 : 메모이제이션은 배열을 하나 만들어서 연산된 값을 저장하여 기억하고, 중복된 연산이 나왔을 때, 해당 연산을 생략함으로써 계산속도를 보다 더 원활하고 빠르게 하기 위해서 사용한다.
DP라고도 하는데, 피보나치 함수 등에서 사용한다(1003.cpp 참고)


6.
string형 자료형은 strlen()으로 길이를 검사할 수 없다.
word.length() 처럼 자바 스타일로 써 줘야 함.


7.
순열과 수열 구하기엔 next_permutation, prev_permutation 함수를 사용한다. (2798.cpp 참고)


8.
유클리드 호제법: 최소공배수, 최대공약수를 구하는 알고리즘.


9.
두 개의 변수를 묶어 사용하고 싶으면 pair(),
세 개의 변수를 묶어 사용하고 싶으면 tuple().
그 이상부터는 뭐 함수는 딱히 없는데 구조체를 쓰면 되는 건가?
묶어 저장한 것들을 정렬하고 싶으면 multiset같은 자동 정렬되는 셋에 넣으면 된다.


10.
c언어로 졸라 개고생하면서 구현했던 큐, 스택 등의 자료구조가 c++에는 헤더 파일로 제공된다ㄷㄷ
사서 또 고생하지 말고 적극 활용하도록 하자


11.
유니온 파인드
💡 핵심 기능 2개
1. find(x)
x가 속한 팀(집합)의 대표 번호(부모)를 찾는 함수
예: find(3) → 3번 사람이 속한 그룹의 대표 번호 리턴

2. union(x, y)
x와 y를 같은 팀으로 합치는 함수
→ 즉, x와 y가 같은 집합(팀)이라고 선언

union(a, b)는 단순히 a가 b를 먹는다가 아니라
a와 b의 루트를 찾아서 한 쪽을 다른 쪽에 붙이는 것임.

근데 내장함수가 아니라서 직접 parent배열 선언하고 find, union함수도 만들어 줘야 함. 번거롭긴 한데 자료구조가 쓸만해서 다시 사용할 일이 있을 듯.


12.
문자열에서 원하는 문자or문자열을 검색할 떄
변수.find(찾는 문자열)사용 / #include <string>
찾는 문자가 없으면 string::npos를 반환함을 이용한다.


13.
소수 구하기 알고리즘: 에라토스테네스의 체
시간 초과 안 걸리기에는 이 알고리즘이 제일 편함.


14.
특정 수가 있는지 없는지 확인하는, 집합 문제의 경우 set보다 bitset을 사용하는 게 획기적으로 빠르다(11723.cpp 참고)


15.
cout가 생각보다 시간이 오래 걸리는 명령이라 반복문 안에 들어 있으면 시간이 오래 걸릴 가능성이 높다.


16.
챗지피티 믿지 마라.
이새기 극도의 효율충이라 네가 만든 코드가 걔 마음에 들 정도로 효율적이지 못하면 기존 코드에서 변수 하나 고치면 돌아갈거 죽어도 어디가 틀렸는지 안 알려주고 계속 자기 코드만 쓰라고 들이댄다.
줏대있는 미친새기임. 절대로 얘한데 큰 일 맡기면 안됨.


17.
deque vs vector
대부분의 경우에서 vector가 더 효율적이지만, deque는 vector에서 비효율적인 '앞 부분 삽입'이 빠르다. 앞뒤 삽입/삭제가 모두 자주 발생하는 경우에만 deque를 선택하여 사용하면 된다.


18.
반복 횟수가 같다면 while과 for문의 시간 차이는 0에 가깝다.
원하는 대로, 최대한 가독성 있는 대로 사용해도 좋다!


19.
그래프 탐색 이론: bfs와 dfs
bfs(넓이 우선 탐색): 최단거리 / 최소 이동 횟수 / 레벨 탐색.. 등
-> 큐를 돌리며 방문 표시를 할 때, 큐에 넣을 때 방문 표시로 visited을 바꿔주는 것이 안전하다. while문의 시작에 visited값을 바꾸면 중복값이 출력될 수 있음.

dfs(깊이 우선 탐색): 경로 탐색 / 모든 경우의 수 / 연결 요소 파악.. 등
둘 다 가능한 경우: 도달 가능한 노드 개수 / 연결 요소 개수 세기.. 등